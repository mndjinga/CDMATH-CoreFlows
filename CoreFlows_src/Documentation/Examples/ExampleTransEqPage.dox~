/*!
\page ExampleTransportEqPage  Example cases for : \a The \a transport \a equation 
[TOC]


 \section Trans1 Problem Transport 1D Heated Channel (C)

\include TransportEquation_1DHeatedChannel.cxx

\code
#include "ProblemTransport.hxx"

using namespace std;

int TransportEquation_1DHeatedChannel()
{
	//Preprocessing: mesh and group creation
	double xinf=0.0;
	double xsup=4.2;
	int nx=10;
	cout << "Building a 1D mesh with "<<nx<<" cells" << endl;
	Mesh M(xinf,xsup,nx);
	double eps=1.E-8;
	M.setGroupAtPlan(xsup,0,eps,"Neumann");
	M.setGroupAtPlan(xinf,0,eps,"Inlet");
	int spaceDim = M.getSpaceDimension();

	// Boundary conditions
	map<string, LimitField> boundaryFields;

	LimitField limitNeumann;
	limitNeumann.bcType=Neumann;
	boundaryFields["Neumann"] = limitNeumann;

	LimitField limitInlet;
	limitInlet.bcType=Inlet;
	limitInlet.T =573.;//Inlet water temperature
	boundaryFields["Inlet"] = limitInlet;

	//Set the fluid transport velocity
	vector<double> transportVelocity(1,5);//fluid velocity vector

	TransportEquation  myProblem(Liquid,around155bars,transportVelocity);
	Field VV("Enthalpie", CELLS, M, 1);

	//Set rod temperature and heat exchamge coefficient
	double rodTemp=623;//Rod clad temperature
	double heatTransfertCoeff=1000;//fluid/solid exchange coefficient 
	myProblem.setRodTemperature(rodTemp);
	myProblem.setHeatTransfertCoeff(heatTransfertCoeff);

	//Initial field creation
	Vector VV_Constant(1);//initial enthalpy
	VV_Constant(0) = 1.3e6;

	cout << "Construction de la condition initiale ... " << endl;

	// generate initial condition
	myProblem.setInitialFieldConstant(M,VV_Constant);

	//set the boundary conditions
	myProblem.setBoundaryFields(boundaryFields);


	// set the numerical method
	myProblem.setNumericalMethod(upwind, Explicit);

	// name result file
	string fileName = "1DRodTemperatureConstant";

	// parameters calculation
	unsigned MaxNbOfTimeStep =3;
	int freqSave = 1;
	double cfl = 0.95;
	double maxTime = 5;
	double precision = 1e-6;

	myProblem.setCFL(cfl);
	myProblem.setPrecision(precision);
	myProblem.setMaxNbOfTimeStep(MaxNbOfTimeStep);
	myProblem.setTimeMax(maxTime);
	myProblem.setFreqSave(freqSave);
	myProblem.setFileName(fileName);
	bool ok;

	// set display option to monitor the calculation
	bool computation=true;
	bool assembling=true;
	bool system=true;
	bool minimal=true;
	myProblem.setDISPLAY( computation, assembling, system, minimal);

	// evolution
	myProblem.initialize();
	ok = myProblem.run();
	if (ok)
		cout << "Simulation "<<fileName<<" is successful !" << endl;
	else
		cout << "Simulation "<<fileName<<"  failed ! " << endl;

	cout << "------------ End of calculation -----------" << endl;
	myProblem.terminate();

	return ok;
}

\endcode


 \section TransDiffus Coupled Problem Transport Diffusion 1D Heated Channel (C)

\code 
#include "ProblemTransport.hxx"
#include "ProblemDiffusion.hxx"

using namespace std;

#define PI 3.14159265

void power_field_CoupledTransportDiffusionTest(Field & Phi){
	double L=4.2;
	double lambda=0.2;
	double phi=1e5;
	double x;
	Mesh M = Phi.getMesh();
	int nbCells = M.getNumberOfCells();
	for (int j = 0; j < nbCells; j++) {
		x=M.getCell(j).x();
		Phi(j) = phi*cos(PI*(x-L/2)/(L+lambda));
	}
}

int CoupledTransportDiffusionEquations_1DHeatedChannel()
{
	//Preprocessing: mesh and group creation
	double xinf=0.0;
	double xsup=4.2;
	int nx=100;
	double eps=1.E-6;
	cout << "Building of the diffusion mesh with "<<nx<<" cells" << endl;
	Mesh diffusionMesh(xinf,xsup,nx);
	diffusionMesh.setGroupAtPlan(xsup,0,eps,"Neumann");
	diffusionMesh.setGroupAtPlan(xinf,0,eps,"Neumann");

	cout << "Building of the transport mesh with "<<nx<<" cells" << endl;
	Mesh transportMesh(xinf,xsup,nx);
	transportMesh.setGroupAtPlan(xsup,0,eps,"Neumann");
	transportMesh.setGroupAtPlan(xinf,0,eps,"Inlet");
	int spaceDim = 1;

	// Boundary conditions 
	map<string, LimitField> boundaryFields;

	// Boundary conditions for the solid
	LimitField limitNeumann;
	limitNeumann.bcType=Neumann;
	boundaryFields["Neumann"] = limitNeumann;

	// Boundary conditions for the fluid
	LimitField limitInlet;
	limitInlet.bcType=Inlet;
	limitInlet.T =573.;//Inlet water temperature
	boundaryFields["Inlet"] = limitInlet;

	//Set the fluid transport velocity
	vector<double> transportVelocity(1,5);//Vitesse du fluide

	//Solid parameters
	double cp_ur=300;//Uranium specific heat
	double rho_ur=10000;//Uranium density
	double lambda_ur=5;

	TransportEquation  myTransportEquation(Liquid, around155bars,transportVelocity);
	Field fluidEnthalpy("Enthalpie", CELLS, transportMesh, 1);
	DiffusionEquation  myDiffusionEquation(spaceDim,rho_ur, cp_ur, lambda_ur);

	Field solidTemp("Solid temperature", CELLS, diffusionMesh, 1);
	Field fluidTemp("Fluid temperature", CELLS, transportMesh, 1);

	double heatTransfertCoeff=10000;//fluid/solid heat exchange coefficient
	myTransportEquation.setHeatTransfertCoeff(heatTransfertCoeff);
	myDiffusionEquation.setHeatTransfertCoeff(heatTransfertCoeff);

	//Set heat source in the solid
	Field Phi("Heat power field", CELLS, diffusionMesh, 1);
	power_field_CoupledTransportDiffusionTest(Phi);
	myDiffusionEquation.setHeatPowerField(Phi);
	Phi.writeVTK("1DheatPowerField");

	//Set the transport velocity in the fluid
	Vector transportVelocity(1);//fluid velocity
	transportVelocity[0]=5;
	myTransportEquation.setTransportVelocity(transportVelocity);

	//Initial field creation
	Vector VV_Constant(1);
	VV_Constant(0) = 623;//Rod clad temperature nucleaire

	cout << "Construction de la condition initiale " << endl;
	// generate initial condition
	myDiffusionEquation.setInitialFieldConstant(diffusionMesh,VV_Constant);


	VV_Constant(0) = 1.3e6;
	myTransportEquation.setInitialFieldConstant(transportMesh,VV_Constant);

	//set the boundary conditions
	myTransportEquation.setBoundaryFields(boundaryFields);//Neumann and Inlet BC will be used
	myDiffusionEquation.setBoundaryFields(boundaryFields);//Only Neumann BC will be used

	// set the numerical method
	myDiffusionEquation.setNumericalMethod(upwind, Explicit);
	myTransportEquation.setNumericalMethod(upwind, Explicit);

	// name result file
	string fluidFileName = "Fluid";
	string solidFileName = "SolidTemperature";

	// parameters calculation
	unsigned MaxNbOfTimeStep =3;
	int freqSave = 10;
	double cfl = 0.5;
	double maxTime = 1000000;
	double precision = 1e-6;

	myDiffusionEquation.setCFL(cfl);
	myDiffusionEquation.setPrecision(precision);
	myDiffusionEquation.setMaxNbOfTimeStep(MaxNbOfTimeStep);
	myDiffusionEquation.setTimeMax(maxTime);
	myDiffusionEquation.setFreqSave(freqSave);
	myDiffusionEquation.setFileName(solidFileName);

	myTransportEquation.setCFL(cfl);
	myTransportEquation.setPrecision(precision);
	myTransportEquation.setMaxNbOfTimeStep(MaxNbOfTimeStep);
	myTransportEquation.setTimeMax(maxTime);
	myTransportEquation.setFreqSave(freqSave);
	myTransportEquation.setFileName(fluidFileName);

	// loop on time steps
	myDiffusionEquation.initialize();
	myTransportEquation.initialize();

	double time=0,dt=0;
	int nbTimeStep=0;
	bool stop=false, stop_transport=false, stop_diffusion=false; // Does the Problem want to stop (error) ?
	bool ok; // Is the time interval successfully solved ?

	// Time step loop
	while(!stop && !(myDiffusionEquation.isStationary() && myTransportEquation.isStationary()) &&time<maxTime && nbTimeStep<MaxNbOfTimeStep)
	{
		ok=false; // Is the time interval successfully solved ?
		fluidTemp=myTransportEquation.getFluidTemperatureField();
		solidTemp=myDiffusionEquation.getRodTemperatureField();
		myDiffusionEquation.setFluidTemperatureField(fluidTemp);
		myTransportEquation.setRodTemperatureField(solidTemp);
		// Guess the next time step length
		dt=min(myDiffusionEquation.computeTimeStep(stop),myTransportEquation.computeTimeStep(stop));
		if (stop){
			cout << "Failed computing time step "<<nbTimeStep<<", time = " << time <<", dt= "<<dt<<", stopping calculation"<< endl;
		break;
		}
		// Loop on the time interval tries
		while (!ok && !stop )
		{
			stop_transport=!myTransportEquation.initTimeStep(dt);
			stop_diffusion=!myDiffusionEquation.initTimeStep(dt);
			stop=stop_diffusion && stop_transport;

			// Prepare the next time step
			if (stop){
				cout << "Failed initializing time step "<<nbTimeStep<<", time = " << time <<", dt= "<<dt<<", stopping calculation"<< endl;
			break;
			}
			// Solve the next time step
			ok=myDiffusionEquation.solveTimeStep()&& myTransportEquation.solveTimeStep();

			if (!ok)   // The resolution failed, try with a new time interval.
			{
				myDiffusionEquation.abortTimeStep();
				myTransportEquation.abortTimeStep();
					cout << "Failed solving time step "<<nbTimeStep<<", time = " << time<<" dt= "<<dt<<", cfl= "<<cfl <<", stopping calculation"<< endl;
					stop=true; // Impossible to solve the next time step, the Problem has given up
					break;
			}
			else // The resolution was successful, validate and go to the next time step.
			{
				cout << "Time step = "<< nbTimeStep << ", dt = "<< dt <<", time = "<<time << endl;
				myDiffusionEquation.validateTimeStep();
				myTransportEquation.validateTimeStep();
				time=myDiffusionEquation.presentTime();
				nbTimeStep++;
			}
		}
	}
	if(myDiffusionEquation.isStationary() && myTransportEquation.isStationary())
		cout << "Stationary state reached" <<endl;
	else if(time>=maxTime)
		cout<<"Maximum time "<<maxTime<<" reached"<<endl;
	else if(nbTimeStep>=MaxNbOfTimeStep)
		cout<<"Maximum number of time steps "<<MaxNbOfTimeStep<<" reached"<<endl;
	else
		cout<<"Error problem wants to stop!"<<endl;

	cout << "End of calculation time t= " << time << " at time step number "<< nbTimeStep << endl;
	if (ok)
		cout << "Coupled simulation "<<fluidFileName<<" and "<<solidFileName<<" was successful !" << endl;
	else
		cout << "Coupled simulation "<<fluidFileName<<" and "<<solidFileName<<"  failed ! " << endl;

	cout << "------------ End of calculation -----------" << endl;
	myDiffusionEquation.terminate();
	myTransportEquation.terminate();

	return ok;
}
\endcode

 \section Trans1py Problem Transport 1D Heated Channel (python)

\code
import CoreFlows as cf

def main():

	spaceDim = 1;
    # Prepare for the mesh
	xinf = 0 ;
	xsup=4.2;
	nx=10;

    # set the limit field for each boundary
	inletTemperature=573;

    # physical constants
	Tref=618;#boiling temperature at 155 bars
	href=1.6e6;#liquid saturation enthalpy at 155 bars
	cpref=9000;#Water specific heat at 155 bars
	rho_ref=600;#liquid density at 573K and 155 bars

	myProblem = cf.TransportEquation(spaceDim,Tref,href,cpref);
	nVar = myProblem.getNumberOfVariables();

    # Prepare for the initial condition
	VV_Constant =[]


	# constant vector
	VV_Constant = [1.3e6]; #initial enthalpy

	rho_ref=600;#liquid density
	myProblem.setLiqSatDensity(rho_ref);

	#Set rod temperature and heat exchamge coefficient
	rodTemp=623;#Rod clad temperature 
	heatTransfertCoeff=1000;#fluid/solid heat exchange coefficient
	myProblem.setRodTemperature(rodTemp);
	myProblem.setHeatTransfertCoeff(heatTransfertCoeff);

    #Initial field creation
	print("Building initial data " );
	myProblem.setInitialFieldConstant(spaceDim,VV_Constant,xinf,xsup,nx,"inlet","neumann");
 
    # Set the boundary conditions
	myProblem.setInletBoundaryCondition("inlet", inletTemperature);
	myProblem.setNeumannBoundaryCondition("neumann")

    # Set the transport velocity
	transportVelocity=[5];
	myProblem.setTransportVelocity(transportVelocity);

    # Set the numerical method
	myProblem.setNumericalMethod(cf.upwind, cf.Implicit);

    # name file save
	fileName = "1DRodTemperatureConstant";

    # parameters calculation
	MaxNbOfTimeStep = 3 ;
	freqSave = 5;
	cfl = 0.95;
	maxTime = 5;
	precision = 1e-6;

	myProblem.setCFL(cfl);
	myProblem.setPrecision(precision);
	myProblem.setMaxNbOfTimeStep(MaxNbOfTimeStep);
	myProblem.setTimeMax(maxTime);
	myProblem.setFreqSave(freqSave);
	myProblem.setFileName(fileName);

     # evolution
	myProblem.initialize();
	print("Running "+ fileName );

	ok = myProblem.run();
	if (ok):
		print( "Simulation " + fileName + " is successful !" );
		pass
	else:
		print( "Simulation " + fileName + "  failed ! " );
		pass

	print( "------------ End of calculation !!! -----------" );

	myProblem.terminate();
	return
\endcode


*/

